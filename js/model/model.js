FMF = window.FMF || {};

FMF.model = (function() {
    'use strict';

    /*
     * There are three DIFFICULTY levels: Level 1 uses 0-5,
     * Level 2 uses 1-10 and Level 3 uses 1-12 to create
     * addition, subtraction, multiplication & division
     * problems.
     *
     * 'level#nums' is an array of the number range used for
     * a specific difficulty level. Note that 'level0nums'
     * corresponds to Level 1, and so on.
     */
    var level0nums = [0, 1, 2, 3, 4, 5];
    var level1nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    var level2nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    var numRanges =  [level0nums, level1nums, level2nums];
    
    /*
     * Each 'level#drills' array includes all of the 
     * practice levels for a specific difficulty level.
     * For example, users can choose '+ 2' to focus on practicing
     * 1 + 2, 2 + 2, 3 + 2 etc. Or, to practice ALL combinations
     * of problems in the range, users can choose '+0...5'. 
     * The arrays below are used to generate the needed mix of
     * problems.
     * Note that these are arrays of arrays -
     * it's intentionally set up this way so that problem sets
     * can be generated for various sets of numbers (i.e. 0...5) 
     * as well as individual numbers.
     * NOTE: These ranges are specifed here instead of
     * generated by a loop using numRanges for flexibility.
     * Setting it here makes it possible to include less straight-forward
     * drill arrays such as [1, 2, 5] in the future.
     */  
    var level0drills = [[0],[1],[2],[3],[4],[5],numRanges[0]];
    var level1drills = [[1],[2],[3],[4],[5],[6],[7],
                        [8],[9],[10],numRanges[1]];
    var level2drills = [[1],[2],[3],[4],[5],[6],[7],[8],
                        [9],[10],[11],[12],numRanges[2]];
    var drillRanges = [ level0drills, level1drills, level2drills];

    // Define drill ranges without '0' for division
    var level0drillsDiv = [[1],[2],[3],[4],[5],numRanges[0]];
    var level1drillsDiv = level1drills;
    var level2drillsDiv = level2drills;
    var drillRangesDiv = [ level0drillsDiv, level1drillsDiv,
                         level2drillsDiv];

    /*
     * Each 'level#labels' array is used for labeling the submenu
     * and report headers.
     */
    var level0labels = ['0','1','2','3','4','5','0 ...5'];
    var level1labels = ['1','2','3','4','5','6','7',
                        '8','9','10','1 ...10'];
    var level2labels = ['1','2','3','4','5','6','7','8',
                        '9','10','11','12','1 ...12'];
    var labelRanges = [ level0labels, level1labels, level2labels];
    
    // Define labels array without '0' for division
    var level0labelsDiv = ['1','2','3','4','5','1 ...5'];
    var level1labelsDiv = level1labels;
    var level2labelsDiv = level2labels;
    var labelRangesDiv = [ level0labelsDiv, level1labelsDiv,
                         level2labelsDiv];
    
    var publicAPI = {

        diff: -1,    //Set in controller.handleStartLevel
        drillRange: [],    //Set in model.setDrillRanges
        drillRangeDiv: [],    //Set in model.setDrillRanges
        labelRange: [],    //Set in model.setDrillRanges
        labelRangeDiv: [],    //Set in model.setDrillRanges
        levelIndex: 0,      // Set in controller.handleChangeLevel and in model.updateLevelMenu
        numRange: [],    //Set in model.setDrillRanges
        operator: '',  // Set in controller.changeOperator
        opName: '',  // Set in controller.changeOperator
        perPage: 5,
        problemIndex: -1,
        problemSet: [],     // Set in model.getProblemArray
        results: {},    //Set in model.initializeResults
        tScore: 0,      //Incremented with each correct answer
        user: '(name)',

        bumpUp: function() {
            var problemIndex = this.problemIndex;
            var perPage = this.perPage;

            /*
             * Adjust problem index so that fresh set of problems
             * displays EVEN IF user hasn't reached end of current set
             * (This is to avoid starting a timed test midway through a set &
             * also to clear out a test set when timer stops.)
             */
            this.problemIndex = problemIndex + perPage - 
                                (problemIndex % perPage);
        },
        changeOperator: function(opName) {
            var symbol = '';
            var operator;
            var lblArray = [];

            this.opName = opName;
            
            // Set label array for +. - and x
            lblArray = this.labelRange;

            /*
             * Depending on operator, get symbol (for display) and
             * operator (used in HTML)
             */
            if (opName === 'add') {
                operator = '+';
                symbol = '+';
            } else if (opName === 'subtract') {
                operator = '-';
                symbol = '-';
            } else if (opName === 'multiply') {
                operator = '&times;';
                symbol = '\xD7';
            } else if (opName === 'divide') {
                operator = '&divide;';
                symbol = '\xF7';
                
                // Use different label array for div (excludes 0)
                lblArray = this.labelRangeDiv;
            } else {
                alert('Error: "' + opName + '" is not a valid option.');
                return;
            }
            this.operator = operator;

            $('.valop').text(symbol);
            setColors();
            updateLevelMenu(lblArray);

            // Adjust colors to reflect selected operator
            function setColors() {
                var idName = '#math_' + opName;
                var className = opName + 'Color';

                // Remove any of the color classes before resetting
                $('[id^="answer"]').removeClass('error');
                $('.page').removeClass('addColor');
                $('.page').removeClass('subtractColor');
                $('.page').removeClass('multiplyColor');
                $('.page').removeClass('divideColor');

                /*
                 * Set colors (yellow = wrong answer, blue = addition
                 * red = subtraction, green = multiplication, purple = division)
                 */
                if (operator === '+') {
                    $('.page').addClass('addColor');
                } else if (operator === '-') {
                    $('.page').addClass('subtractColor');
                } else if (operator === '&times;') {
                    $('.page').addClass('multiplyColor');
                } else if (operator === '&divide;') {
                    $('.page').addClass('divideColor');
                }

                // Adjust colors in main menu
                if (!($(idName).hasClass(className))) {

                    // Remove all colored borders
                    $('#math_add').removeClass('addColor');
                    $('#math_subtract').removeClass('subtractColor');
                    $('#math_multiply').removeClass('multiplyColor');
                    $('#math_divide').removeClass('divideColor');

                    $(idName).addClass(className);
                }
            }

            function updateLevelMenu(labelRange) {
                var listHTML = '';

                // Create html string used to generate submenu
                for (var i = 0, l = labelRange.length; i < l ; i +=1) {
                    listHTML += '<li><a href="#">&nbsp&nbsp' + operator +
                                '' + labelRange[i] + '</a></li>';
                }

                // Update list options in levelMenu
                $('#levelMenu').html(listHTML);

                // Intially default to first level
                $('#levelMenu li').removeClass('active');
                $('#levelMenu li').first().addClass('active');
            }        
        },
        checkAns: function(topVal, bottomVal, answer, correctAns, isTimed) {
            var result = this.results[this.opName].level[this.levelIndex];
            var testCount;

            if (isTimed) {
                testCount = result.timed.length - 1;
            }

            // Increment ctr to keep track of total # of problems answered
            this.problemIndex +=1;

            /*
             * If answer is incorrect, set error flag to true and record 
             * error. (For practice sessions only, also highlight errors)
             */
            if (answer !== correctAns) {

                // Add error array to results
                result.errors.push([topVal, bottomVal, answer, correctAns]);

                /*
                 * If not timed test, add 'error' class to highlight error
                 * (decided not to distract users with highlight during
                 * a timed test)
                 */
                if(!isTimed) {
                    $('.live').addClass('error');
                }

            /*
             * Otherwise, if answer is correct, increment # of CORRECT
             * answers for practice or timed
             */
            } else {

                // Increment overall counter for # correct problems
                this.tScore ++;

                // Either increment # for timed count, or practice count
                if (isTimed) {
                    result.timed[testCount][0] ++;
                } else {
                    result.practice[0] ++;
                    $("#trackScore").html("+" + this.tScore);
                }

                /*
                 * If not timed test, display green check mark to
                 * indicate correct answer (& fade out)
                 */
                if(!isTimed) {
                    $('.live + i').addClass('fadeInOutOnce');
                }
            }

            /*
             * Increment counter for # problems ATTEMPTED - either
             * 'practice' or 'timed'
             */
            if (isTimed) {
                result.timed[testCount][1] ++;
            } else {
                result.practice[1] ++;
            }
        },
        doubleArray: function() {
            var problemSet = this.problemSet;

            // Double size of problem set with concat
            problemSet = problemSet.concat(problemSet);
            this.problemSet = problemSet;
        },
        getAddOrMult: function(tempNums, drillArray) {
            var basicProblemSet = [];
            var operator = this.operator;
            var correctAns;

            /*
             * Loops cycle through array values to create an array of
             * addition or multiplication problems (depending on 
             * value of 'operator').
             * Note that at this stage duplicate problems are excluded
             * (array will not contain BOTH 4 + 5 = 9 and 5 + 4 = 9).
             */
            for (var j = (drillArray.length-1), m = 0; m <= j; j -= 1) {
                for (var i = (tempNums.length-1), l = 0; l <= i; i -= 1) {

                    if (operator === '+') {
                        correctAns = drillArray[j] + tempNums[i];
                    } else if (operator === '&times;') {
                        correctAns = drillArray[j] * tempNums[i];
                    }

                    /*
                     * Randomize the order of the addends/factors for
                     * display purposes
                     * (example: if user chooses '+2' from menu,
                     * vary whether '2' displays as
                     * the first or second addend in the problems)
                     */
                    if (Math.floor(Math.random()*2)) {
                        basicProblemSet.push([drillArray[j],
                                tempNums[i], correctAns]);
                    } else {
                        basicProblemSet.push([tempNums[i],
                                drillArray[j], correctAns]);
                    }
                }

                /*
                 * If the value drillArray[j] is also in tempNums,
                 * splice it out of tempNums
                 * to avoid creating duplicate problems
                 */
                var lookForMatch = tempNums.indexOf(drillArray[j]);

                if (lookForMatch !== -1) {
                    tempNums.splice(lookForMatch, 1);
                }
            }

            return this.shuffleAndExpand(basicProblemSet);
        },
        getDivision: function(tempNums, drillArray) {
            var basicProblemSet = [];
            var dividend;

            /*
             * Loops cycle through array values to create an array of
             * division problems.
             * Note that the 'tempNum' values are assigned to the RESULT
             * (quotient) of the division problem, and the 'drillArray'
             * values are the divisors. The top number in the division
             * problem (the dividend) is the product of the 'tempNum' and
             * 'drillArray' values. (example: if tempNum is 3 and
             * drillArray is 2, then problem will be
             * 6 divided by 2 = 3)
             */
            for (var j = (drillArray.length-1), m = 0; m <= j; j -= 1) {
                if (drillArray[j] === 0) continue;
                for (var i = (tempNums.length-1), l = 0; l <= i; i -= 1) {
                    dividend = drillArray[j] * tempNums[i];
                    basicProblemSet.push([dividend, drillArray[j],
                            tempNums[i]]);
                }
            }

            return this.shuffleAndExpand(basicProblemSet);
        },
        getProblemArray: function (newIndex) {
            var drillArray = [];
            var operator = this.operator;

            this.levelIndex = newIndex;

            // Use special array for division (excludes zero)
            if (this.opName === 'divide') {
                drillArray = this.drillRangeDiv[this.levelIndex];
            } else {
                drillArray = this.drillRange[this.levelIndex];
            }

            /*
             * Make a COPY of the numRange array (because it gets
             * modified in fcn calls below)
             */
            var tempNums = this.numRange.slice();

            /*
             * Clear problemSet array before creating new array
             * of problems; set index to 0
             */
            this.problemSet.length = 0;
            this.problemIndex = 0;

            if ((operator === '+') || (operator === '&times;')) {
                this.problemSet = this.getAddOrMult(tempNums, drillArray);
            } else if (operator === '-') {
                this.problemSet = this.getSubtraction(tempNums, drillArray);
            } else if (operator === '&divide;') {
                this.problemSet = this.getDivision(tempNums, drillArray);
            } else {
                alert('The operator "' + operator + '" is not valid.');
                return;
            }
        },
        getSubtraction: function(tempNums, drillArray) {
            var basicProblemSet = [];
            var minuend;

            /*
             * Loops cycle through array values to create an array of
             * subtraction problems.
             * Note that the 'tempNum' values are assigned to the RESULT
             * of the subtraction problem, and the 'drillArray' values
             * are what gets subtracted. The top number in the subtraction
             * problem (the minuend) is the SUM of the 'tempNum' and
             * 'drillArray' values.
             * (example: if tempNum is 3 and drillArray is 2, then
             * problem will be 5 - 2 = 3)
             */
            for (var j = (drillArray.length-1), m = 0; m <= j; j -= 1) {
                for (var i = (tempNums.length-1), l = 0; l <= i; i -= 1) {
                    minuend = drillArray[j] + tempNums[i];
                    basicProblemSet.push([minuend, drillArray[j],
                            tempNums[i]]);
                }
            }

            return this.shuffleAndExpand(basicProblemSet);
        },
        shuffleAndExpand: function(basicProblemSet) {
            var newProblems = [];
            var reshuffledSet = [];
            var ctr;

            // Shuffle basic problem set, to mixup order for display
            newProblems = _.shuffle(basicProblemSet);

            /*
             * Goals for problem sets:
             *      1) If there are 12 unique problems for a given level,
             *          display all 12 before any repeat problems.
             *      2) Instead of just repeating the problem set in same
             *         order, concat some shuffled arrays to the problem set.
             *          So 36 problems will cover each problem set of
             *          12 three times,
             *          but in a different order each round. (This issue
             *          is most noticeable to a user if # of unique problems
             *          is small - esp. for beginners working with just 0-5.)
             *      3) Prevent consecutive problems from being identical,
             *          which can happen if the first problem in the newly
             *          shuffled array matches the last problem in
             *          newProblems array. (so before concat. a shuffled
             *          array to newProblems, check if 1st element of
             *          shuffled array matches last element of newProblems. 
             *          If it does,
             *          push & shift shuffled array before concat.)
             */
            for (var i = 1; i < 4 ; i +=1 ) {
                ctr = newProblems.length;
                reshuffledSet = _.shuffle(basicProblemSet);

                /*
                 * To prevent the same problem appearing 2x in a row,
                 * check if last el of newProblems matches first
                 * el of shuffled set.
                 * If it matches, uses push & shift before concat.
                 */
                if ((newProblems[ctr-1][0] === reshuffledSet[0][0]) &&
                        (newProblems[ctr-1][1] === reshuffledSet[0][1])) {
                    reshuffledSet.push(reshuffledSet[0]);
                    reshuffledSet.shift();
                }

                newProblems = newProblems.concat(reshuffledSet);
            }

            /*
             * Now newProblems contains multiple sets of the basicProblemSet.
             * Check if last element matches first. If yes,
             * splice location of last element (-3). (If the user does
             * more problems than the length of the newProblems array,
             * the app will cycle through the array a second time -
             * so matching first & last elements would make the same problem
             * appear twice in a row.)
             */
            ctr = newProblems.length;
            if ((newProblems[ctr-1][0] === newProblems[0][0]) &&
                    (newProblems[ctr-1][1] === newProblems[0][1])) {
                newProblems.splice(-3,0,newProblems[ctr-1]);
                newProblems.splice(-1,1);
            }

            return newProblems;
        },
        setName: function(userName) {
            if (typeof(userName) !== 'undefined' && userName !== '') {
                this.user = userName;
            }
        },
        setProblemRanges: function(difficulty) {
            var results = this.results;

            this.diff = difficulty;

            /*
             * Get arrays used to generate problems
             * based on difficulty level user selected.
             */
            this.numRange = numRanges[difficulty];
            this.drillRange = drillRanges[difficulty];
            this.labelRange = labelRanges[difficulty];            
            this.drillRangeDiv = drillRangesDiv[difficulty];
            this.labelRangeDiv = labelRangesDiv[difficulty];            
            
            // Define results object to track user's results
            results.add = new Results('+', this.drillRange, this.labelRange);
            results.subtract = new Results('-', this.drillRange,
                               this.labelRange);
            results.multiply = new Results('\xD7', this.drillRange,
                               this.labelRange);
            results.divide = new Results('\xF7', this.drillRangeDiv,
                             this.labelRangeDiv);
                        
            function Results(op, drRange, lblRange) {
                this.level = [];
                for(var i = 0, l = drRange.length; i < l; i++) {        
                    this.level[i] = {drillArray:[],label:'',
                                    practice:[0,0],timed:[],errors:[]};
                    this.level[i].drillArray = drRange[i];
                    this.level[i].label =  op + lblRange[i];
                }
            }
        }
    };
    return publicAPI;
})();
